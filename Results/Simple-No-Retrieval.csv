Test Case ID,Category,Difficulty,Question,Ground Truth Cypher,Generated Cypher,Syntactic Correct,Execution Success,Semantic Accurate,Manual Override,Final Correctness,Tokens Used,Execution Time (s),Execution Error,Context Used
1,filtering,easy,What job category has the most jobs?,"match (j:JobTitle)
return j.category, count(*)
order by count(*) desc
limit 1;","MATCH (j:JobTitle)
WITH j.category AS category, COUNT(j) AS jobCount
ORDER BY jobCount DESC
LIMIT 1
RETURN category, jobCount",True,True,False,True,True,713,5.24,,False
2,filtering,easy,Which gender is more common?,"match (p:Person)
with sum(case when toLower(p.gender) = 'male' then 1 else 0 end) as males,
     sum(case when toLower(p.gender) = 'female' then 1 else 0 end) as females
return case when males > females then 'males' else females end;","MATCH (p:Person)
WITH p.gender AS gender, COUNT(*) AS count
ORDER BY count DESC
LIMIT 1
RETURN gender AS mostCommonGender, count AS frequency",True,True,False,True,True,715,7.63,,False
3,filtering,easy,What is Mark's nationality?,"match (p:Person)
where toLower(p.firstName) = 'mark'
return p.nationality;","MATCH (p:Person)
WHERE toLower(p.firstName) = 'mark'
RETURN p.nationality",True,True,True,,True,698,3.43,,False
4,filtering,easy,How many people are called Mark?,"match (p:Person)
where toLower(p.firstName) = 'mark'
return count(p);","MATCH (p:Person)
WHERE toLower(p.firstName) = 'mark'
RETURN COUNT(p) AS markCount",True,True,False,True,True,701,2.64,,False
5,filtering,easy,What is the number of population of the world at this moment?,"match (l:Location)
return sum(l.population)","MATCH (l:Location {type: 'Country'})
RETURN SUM(l.population) AS worldPopulation",True,True,False,False,False,708,8.84,,False
6,filtering,easy,Who is Jordan's daddy?,"match (p:Person)-[:IS_CHILD]->(daddy:Person)
where daddy.gender = 'Male'
and p.firstName = 'Jordan'
return daddy.firstName;","MATCH (jordan:Person)-[:IS_CHILD]->(father:Person)
WHERE toLower(jordan.firstName) = 'jordan' AND father.gender = 'Male'
RETURN father.firstName + ' ' + father.lastName AS jordansDaddy",True,True,False,True,True,724,4.29,,False
7,filtering,easy,How many people have a younger sister and are working as a Data Scientist?,"match (person:Person)-[:IS_SIBLING]->(sister:Person)
where sister.gender = 'Female'
and sister.birthDate>person.birthDate
with person
match (person)-[j:HAD_POSITION]->(jt:JobTitle)
where toLower(jt.title) = 'data scientist'
and j.endYear is null
return count(distinct person)","MATCH (p:Person)-[:IS_SIBLING]->(sister:Person)
WHERE p.birthDate < sister.birthDate AND sister.gender = 'female'
WITH p
MATCH (p)-[w:WORKED_AT]->(c:Company)
WHERE w.status = 'current'
WITH p
MATCH (p)-[h:HAD_POSITION]->(j:JobTitle)
WHERE h.endYear IS NULL AND toLower(j.title) = 'data scientist'
RETURN COUNT(DISTINCT p) AS count",True,True,False,True,True,774,7.71,,False
8,filtering,easy,Where does Mark work?,"match (p:Person)-[worked:WORKED_AT]-(c:Company)
where toLower(p.firstName) = 'mark'
and worked.status = 'Current'
return c.name;","MATCH (p:Person)-[:WORKED_AT]->(c:Company)
WHERE toLower(p.firstName) = 'mark' AND c.name IS NOT NULL
RETURN c.name AS workplace",True,True,False,False,False,710,3.11,,False
9,filtering,easy,How many people called Mark work in tech industry in spain?,"match (c:Company)-[:WORKED_AT]-(p:Person)-[:LIVES_IN]-(l:Location)
where toLower(l.country) = 'Spain'
and toLower(p.firstName) = 'mark'
and toLower(c.industry) = 'technology'
return count(distinct p);","MATCH (p:Person)-[:WORKED_AT]->(c:Company)
WHERE toLower(p.firstName) = 'mark' AND toLower(c.industry) = 'tech'
  AND EXISTS((c)-[:LIVES_IN]->(:Location {country: 'spain'}))
RETURN COUNT(DISTINCT p) AS markCount",True,True,False,False,False,740,3.02,,False
10,filtering,easy,what is most popular girl's name in New Zealand?,"match (p:Person)-[:LIVES_IN]-(loc:Location)
where loc.country = 'New Zealand'
and p.gender = 'Female'
with p.firstName as firstName, count(*) as nameCount
return firstName, nameCount
order by nameCount desc
limit 1;
","MATCH (p:Person)-[:LIVES_IN]->(l:Location {country: ""New Zealand""})
WHERE p.gender = ""female""
WITH LOWER(p.firstName) AS firstName, COUNT(*) AS count
ORDER BY count DESC
LIMIT 1
RETURN firstName AS mostPopularGirlName, count",True,True,False,False,False,741,4.38,,False
11,filtering,easy,How many doctors named Mia are there in New Zealand?,"match (p:Person)-[worked:HAD_POSITION]-(job:JobTitle)
where p.firstName = 'Mia'
and job.title = 'Doctor'
and worked.endYear is null
return count(distinct p);","MATCH (p:Person)-[:LIVES_IN]->(l:Location {country: ""New Zealand""})
WHERE toLower(p.firstName) = ""mia""
  AND EXISTS((p)-[:HAD_POSITION]->(:JobTitle {title: ""Doctor""}))
RETURN COUNT(DISTINCT p) AS doctorMiasInNewZealand",True,True,False,True,True,740,9.67,,False
12,aggregation,easy,What is the average number of friends among teenagers aged 13 to 39?,"match (teen:Person)
where (duration.between(date(teen.birthDate),date())).years < 40
and (duration.between(date(teen.birthDate),date())).years > 12
optional match (teen)-[:IS_FRIEND]->(friend:Person)
with count(distinct teen) as totalTeens, count(friend) as totalFriends
return toFloat(totalFriends)/totalTeens;","MATCH (p:Person)
WHERE date().year - toInteger(substring(p.birthDate, 0, 4)) >= 13 AND date().year - toInteger(substring(p.birthDate, 0, 4)) <= 39
WITH p, [(p)-[:IS_FRIEND]-(friend) | friend] AS friends
RETURN avg(size(friends)) AS averageFriends",True,True,False,False,False,751,3.95,,False
13,filtering,easy,"How many Samuels, who are over 20, are friends with 31-year-old Dana?","match (samuel:Person)-[:IS_FRIEND]-(dana:Person)
where samuel.firstName = 'Samuel'
and date().year - date(samuel.birthDate).year > 20
and duration.between(date(dana.birthDate), date()).years = 31
and dana.firstName = 'Dana'
return count(distinct samuel);","MATCH (samuel:Person)-[:IS_FRIEND]-(dana:Person)
WHERE toLower(samuel.firstName) = 'samuel'
  AND duration.between(date(samuel.birthDate), date()).years > 20
  AND toLower(dana.firstName) = 'dana'
  AND duration.between(date(dana.birthDate), date()).years = 31
RETURN COUNT(DISTINCT samuel) AS samuelsCount",True,True,False,True,True,766,4.01,,False
14,aggregation,easy,Most popular subject among students at Yemen schools.,"match (f:FieldOfStudy)-[:STUDIED]-(p:Person)-[:STUDIED_AT]-(uni:EducationalInstitution)
where uni.country = 'Yemen'
return f.name, count(distinct p)
order by count(distinct p) desc
limit 1;
","MATCH (p:Person)-[:STUDIED_AT]->(e:EducationalInstitution)-[:LOCATED_IN]->(l:Location {country: ""Yemen""})
MATCH (p)-[:STUDIED]->(f:FieldOfStudy)
WITH f, COUNT(DISTINCT p) AS studentCount
ORDER BY studentCount DESC
LIMIT 1
RETURN f.name AS mostPopularSubject, studentCount",True,True,False,False,False,754,7.79,,False
15,filtering,easy,"How many people are there named Connie, who have studied Business Administration?","match (p:Person)-[:STUDIED]-(f:FieldOfStudy)
where toLower(p.firstName) = 'connie'
and toLower(f.name) = 'business administration'
return count(p);","MATCH (p:Person)-[:STUDIED]->(f:FieldOfStudy)
WHERE toLower(p.firstName) = 'connie' AND toLower(f.name) = 'business administration'
RETURN count(DISTINCT p) AS count",True,True,False,True,True,734,3.14,,False
16,aggregation,easy,What is the average number of residents in the city?,"match (l:Location)
return avg(l.population);","MATCH (l:Location {type: 'CITY'})
WHERE l.population IS NOT NULL
RETURN avg(l.population) AS averageResidents",True,True,False,False,False,713,8.31,,False
17,filtering,medium,What place has the most people?,"match (p:Person)-[:LIVES_IN]-(l:Location)
return l.name, count(p)
order by count(p) desc
limit 1;","MATCH (l:Location)<-[:LIVES_IN]-(p:Person)
WITH l, COUNT(p) AS residentCount
RETURN l.name AS place, residentCount
ORDER BY residentCount DESC
LIMIT 1",True,True,False,True,True,718,3.49,,False
18,filtering,medium,In what educational institution do most people study?,"match (p:Person)-[r:STUDIED_AT]->(ei:EducationalInstitution)
where r.endYear is null
with ei, count(distinct p) as numberOfStudents
order by numberOfStudents desc
limit 1
return ei.name, numberOfStudents;","MATCH (p:Person)-[:STUDIED_AT]->(e:EducationalInstitution)
WITH e, COUNT(DISTINCT p) AS studentCount
RETURN e.name AS institutionName, studentCount
ORDER BY studentCount DESC
LIMIT 1",True,True,False,False,False,731,8.9,,False
19,filtering,medium,What was the population increase from the last 100 years in New Zealand?,,"MATCH (l:Location {name: 'New Zealand'})
WITH l, datetime().year - 100 AS startYear
MATCH (p:Person)-[lived:LIVED_IN]->(l)
WHERE lived.startYear >= startYear OR lived.endYear >= startYear
WITH l, startYear, COUNT(DISTINCT p) AS populationIncrease
RETURN l.name AS country, l.population - populationIncrease AS populationBeforeIncrease, l.population AS currentPopulation, populationIncrease",True,True,False,False,False,788,5.04,,False
20,aggregation,medium,What is the average age in New Zealand?,"match (loc:Location)-[:LIVES_IN]-(p:Person)
where loc.country = 'New Zealand'
return avg(duration.between(date(p.birthDate), date()).years);
","MATCH (p:Person)-[:LIVES_IN]->(l:Location {country: ""New Zealand""})
WHERE p.birthDate IS NOT NULL
WITH p, l, date() AS currentDate, date(p.birthDate) AS birthDate
WITH p, l, duration.between(birthDate, currentDate).years AS age
RETURN avg(age) AS averageAge",True,True,False,True,True,747,3.72,,False
21,aggregation,medium,Is there a correlation between studying abroad and staying there permanently? (assume it's correlated if it's true for more than half of the population),"match (p:Person)-[:STUDIED_AT]-(uni:EducationalInstitution),
      (p)-[:LIVES_IN]-(live:Location)
where uni.country <> p.birthPlace
with count(case when uni.country = live.country then 1 end) as stayed,
     count(case when uni.country <> live.country then 1 end) as left
return case when toFloat(stayed)/(stayed+left) > 0.5 then 'correlated' else 'uncorrelated' end;","MATCH (p:Person)-[s:STUDIED_AT]->(e:EducationalInstitution)
WHERE e.country <> p.nationality
WITH p, e
MATCH (p)-[l:LIVES_IN]->(loc:Location)
WHERE loc.country = e.country AND l.since <= s.endYear
WITH COUNT(DISTINCT p) AS studiedAbroadAndStayed
MATCH (p:Person)-[:STUDIED_AT]->(:EducationalInstitution)
WHERE p.nationality <> (:EducationalInstitution).country
WITH studiedAbroadAndStayed, COUNT(DISTINCT p) AS totalStudiedAbroad
RETURN 
  CASE 
    WHEN totalStudiedAbroad > 0 AND (studiedAbroadAndStayed * 1.0 / totalStudiedAbroad) > 0.5 
    THEN 'There is a correlation between studying abroad and staying there permanently'
    ELSE 'There is no correlation between studying abroad and staying there permanently'
  END AS result",True,False,False,False,False,894,5.89,"{code: Neo.ClientError.Statement.SyntaxError} {message: Invalid input '.': expected '-' (line 8, column 49 (offset: 352))
""WHERE p.nationality <> (:EducationalInstitution).country""
                                                 ^}",False
22,aggregation,medium,Is there a correlation between studying abroad and returning home? (assume it's correlated if it's true for more than half of the population),"match (p:Person)-[:STUDIED_AT]-(uni:EducationalInstitution),
      (p)-[:LIVES_IN]-(liveCountry:Location)
where uni.country <> p.birthPlace
with count(case when liveCountry = p.birthPlace then 1 end) as returned,
     count(case when liveCountry <> p.birthPlace then 1 end) as didnt
return case when toFloat(returned)/(returned+didnt) > 0.5 then 'correlated' else 'uncorrelated' end;","MATCH (p:Person)-[:STUDIED_AT]->(e:EducationalInstitution)
WHERE p.nationality <> e.country
WITH p, e
MATCH (p)-[l:LIVES_IN]->(loc:Location)
WHERE l.since > e.foundedYear AND loc.country = p.nationality
WITH count(DISTINCT p) AS studiedAbroadAndReturned
MATCH (p:Person)
WITH studiedAbroadAndReturned, count(p) AS totalPopulation
RETURN 
    CASE 
        WHEN totalPopulation > 0 THEN 
            CASE 
                WHEN (studiedAbroadAndReturned * 1.0 / totalPopulation) > 0.5 
                THEN 'There is a correlation between studying abroad and returning home'
                ELSE 'There is no correlation between studying abroad and returning home'
            END
        ELSE 'Insufficient data'
    END AS result",True,True,False,True,True,890,5.49,,False
23,aggregation,medium,"Is there a correlation between studying abroad and changing countries again? (assume it's correlated if it's true for more than half of the population)
","match (p:Person)-[:STUDIED_AT]-(uni:EducationalInstitution),
      (p)-[:LIVES_IN]-(live:Location)
where uni.country <> p.birthPlace
with count(case when live.country = uni.country then 1 end) as stayed,
     count(case when live.country <> uni.country then 1 end) as changed
return case when toFloat(changed)/(changed+stayed) > 0.5 then 'correlated' else 'uncorrelated' end;","MATCH (p:Person)-[:STUDIED_AT]->(ei:EducationalInstitution)
WHERE p.nationality <> ei.country
WITH p, ei
MATCH (p)-[:LIVED_IN]->(l:Location)
WHERE l.country <> p.nationality AND l.country <> ei.country
WITH COUNT(DISTINCT p) AS studiedAbroadAndMoved, COUNT(DISTINCT (p:Person)) AS totalPopulation
RETURN 
  CASE 
    WHEN studiedAbroadAndMoved > totalPopulation / 2 THEN 'There is a correlation'
    ELSE 'There is no correlation'
  END AS correlation,
  studiedAbroadAndMoved AS peopleStudiedAbroadAndMoved,
  totalPopulation",True,True,False,True,True,842,5.72,,False
24,aggregation,medium,Is there a correlation between the email of the person being Yahoo! and that person not working in the tech field? (assume it's correlated if it's true for more than half of the population),"match (p:Person)-[:HAD_POSITION]-(job:JobTitle)
where toLower(p.email) ends with '@yahoo.com'
with count(case when job.category = 'Technology' then 1 end) as tech,
     count(case when job.category <> 'Techonology' then 1 end) as notTech
return case when tech+notTech = 0 then 'no yahoo mails' when toFloat(tech)/(tech+notTech) > 0.5 then 'correlated' else 'uncorrelated' end;
","MATCH (p:Person)
WITH p, toLower(p.email) AS lowerEmail, 
     (p)-[:WORKED_AT]->(:Company)-[:HAD_POSITION]->(j:JobTitle) AS workHistory
WITH p, 
     CASE 
       WHEN lowerEmail CONTAINS 'yahoo.com' THEN true 
       ELSE false 
     END AS isYahooEmail,
     CASE 
       WHEN any(job IN workHistory WHERE toLower(job.category) = 'tech') THEN false 
       ELSE true 
     END AS notInTechField
WITH count(p) AS totalPopulation,
     sum(CASE WHEN isYahooEmail AND notInTechField THEN 1 ELSE 0 END) AS yahooNotTechCount,
     sum(CASE WHEN isYahooEmail THEN 1 ELSE 0 END) AS yahooCount
RETURN 
  CASE 
    WHEN yahooCount > 0 AND (yahooNotTechCount * 1.0 / yahooCount) > 0.5 THEN 'Correlated'
    ELSE 'Not correlated'
  END AS correlation,
  yahooCount AS totalYahooUsers,
  yahooNotTechCount AS yahooUsersNotInTech,
  totalPopulation AS totalPopulation",True,False,False,False,False,934,10.03,"{code: Neo.ClientError.Statement.SyntaxError} {message: PatternExpressions are not allowed to introduce new variables: 'j'. (line 3, column 53 (offset: 110))
""     (p)-[:WORKED_AT]->(:Company)-[:HAD_POSITION]->(j:JobTitle) AS workHistory""
                                                     ^}",False
25,aggregation,medium,"On average, how many sisters do people called Charles have?","match (charles:Person)
where charles.firstName = 'Charles'
optional match (charles)-[:IS_SIBLING]->(sister:Person)
where sister.gender = 'Female'
with charles, count(sister) as sisters
return avg(sisters)
","MATCH (p:Person {firstName: 'Charles'})
WITH p, [(p)-[:IS_SIBLING]-(sibling:Person) WHERE sibling.gender = 'Female' | sibling] AS sisters
RETURN avg(size(sisters)) AS avgSisters",True,True,False,False,False,732,4.6,,False
26,filtering,medium,How many Christophers are there that have or have had a friend named Jessica,"match (christopher:Person)-[:IS_FRIEND]->(jessica:Person)
where christopher.firstName = 'Christopher'
and jessica.firstName = 'Jessica'
return count(distinct christopher);","MATCH (christopher:Person)-[:IS_FRIEND]-(jessica:Person)
WHERE toLower(christopher.firstName) = 'christopher' AND toLower(jessica.firstName) = 'jessica'
RETURN COUNT(DISTINCT christopher) AS christopherCount",True,True,False,True,True,743,12.45,,False
27,filtering,medium,How many people work in the same field they studied in?,"match (f:FieldOfStudy)-[:STUDIED]-(p:Person)-[a:HAD_POSITION]-(job:JobTitle)
where f.category = job.category
and a.endYear is null
return count(distinct(p));","MATCH (p:Person)-[:STUDIED]->(f:FieldOfStudy)
WITH p, f
MATCH (p)-[:WORKED_AT]->(c:Company)
WITH p, f, c
MATCH (p)-[:HAD_POSITION]->(j:JobTitle)
WHERE toLower(f.category) = toLower(j.category)
RETURN COUNT(DISTINCT p) AS peopleWorkingInStudiedField",True,True,False,False,False,748,10.2,,False
28,aggregation,medium,"What percentage of people use their name as their email?
","match (p:Person)
with count(p) as totalPeople,
     count(case when p.email is not null and toLower(p.email) contains toLower(p.firstName) then 1 end) as nameEmail
return toFloat(nameEmail) / totalPeople * 100;
","MATCH (p:Person)
WHERE p.email IS NOT NULL AND p.firstName IS NOT NULL AND p.lastName IS NOT NULL
WITH p, toLower(p.firstName + '.' + p.lastName) AS namePart, toLower(split(p.email, '@')[0]) AS emailPart
WITH COUNT(CASE WHEN namePart = emailPart THEN 1 END) AS matchCount, COUNT(p) AS totalCount
RETURN toFloat(matchCount) / totalCount * 100 AS percentage",True,True,False,True,True,776,12.61,,False
29,filtering,medium,In which country are the most amount of people named Jordan?,"match (p:Person)-[:LIVES_IN]-(loc:Location)
where p.firstName = 'Jordan'
return loc.country, count(p)
order by count(p)
limit 1;",,False,False,False,False,False,0,33.9,"Error in test case execution: Claude API Error: Error code: 529 - {'type': 'error', 'error': {'type': 'overloaded_error', 'message': 'Overloaded'}}",False
30,filtering,medium,What positions has Connie's sister worked as?,"match (friend:Person)-[:IS_SIBLING]->(sister:Person)-[worked:HAD_POSITION]-(job:JobTitle)
where toLower(friend.firstName) = 'connie'
return distinct job.title;","MATCH (connie:Person)-[:IS_SIBLING]->(sister:Person)-[worked:HAD_POSITION]->(position:JobTitle)
WHERE toLower(connie.firstName) = 'connie'
RETURN DISTINCT position.title AS SisterPositions",True,True,False,True,True,731,17.61,,False
31,aggregation,medium,How many children on average does a parent have in Grenada?,"match (child:Person)-[:IS_CHILD]->(parent:Person)-[:LIVES_IN]-(loc:Location)
where loc.country = 'Grenada'
with parent, count(child) as children
return avg(children);","MATCH (p:Person)-[:IS_PARENT]->(c:Person)
WHERE toLower(p.nationality) = 'grenada'
WITH p, COUNT(c) AS childCount
RETURN AVG(childCount) AS averageChildrenPerParent",True,True,False,False,False,728,6.66,,False
32,filtering,medium,How many people have studied in universities located in French Southern Territories and have friends who work in finance?,"match (uni:EducationalInstitution)-[:STUDIED_AT]-(p:Person)-[:IS_FRIEND]-(friend:Person)-[:HAD_POSITION]-(job:JobTitle)
where toLower(uni.country) = 'french southern territories'
and toLower(job.category) = 'finance'
return count(distinct p);","MATCH (p:Person)-[:STUDIED_AT]->(u:EducationalInstitution)-[:LIVES_IN]->(l:Location {country: ""French Southern Territories""})
WITH p
MATCH (p)-[:IS_FRIEND]->(f:Person)-[:WORKED_AT]->(c:Company)
WHERE toLower(c.industry) = 'finance'
RETURN COUNT(DISTINCT p) AS peopleCount",True,True,False,False,False,771,10.01,,False
33,filtering,medium,How many people have worked in the education industry and is married to someone who lives in Grenada?,"match (job:JobTitle)-[:HAD_POSITION]-(p:Person)-[:IS_WIFE|IS_HUSBAND]->(spouse:Person)-[:LIVES_IN]-(loc:Location)
where loc.country = 'Grenada'
and job.category = 'Education'
return count(distinct p);
","MATCH (p:Person)-[:WORKED_AT]->(c:Company {industry: 'education'})
WHERE EXISTS((p)-[:IS_HUSBAND|IS_WIFE]-(:Person)-[:LIVES_IN]->(:Location {name: 'Grenada'}))
RETURN COUNT(DISTINCT p) AS count",True,True,False,False,False,746,25.12,,False
34,aggregation,hard,How correlated are education and career? (assume it's correlated if it's true for more than half of the population),"match (job:JobTitle)-[:HAD_POSITION]-(p:Person)
optional match (p)-[:STUDIED_AT]-(uni:EducationalInstitution)
with count(case when uni.id is not null then 1 end) as studied,
     count(case when uni.id is null then 1 end) as didnt
return case when toFloat(studied)/(studied+didnt) > 0.5 then 'correlated' else 'uncorrelated' end;","MATCH (p:Person)
WITH count(p) as totalPopulation
MATCH (p:Person)-[:STUDIED_AT]->(e:EducationalInstitution)
WITH totalPopulation, p, collect(e) as educations
MATCH (p)-[:WORKED_AT]->(c:Company)
WITH totalPopulation, p, educations, collect(c) as companies
WHERE size(educations) > 0 AND size(companies) > 0
WITH totalPopulation, count(p) as correlatedCount
RETURN 
  CASE 
    WHEN (correlatedCount * 1.0 / totalPopulation) > 0.5 
    THEN 'Education and career are correlated' 
    ELSE 'Education and career are not correlated' 
  END as result, 
  round((correlatedCount * 100.0 / totalPopulation), 2) as percentageCorrelated",True,True,False,True,True,858,26.02,,False
35,graph_recursion,hard,How are Matthew and Theresa related?,"match (matthew:Person), (theresa:Person), p = shortestPath((matthew)-[*]-(theresa))
where matthew.firstName = 'Matthew'
and theresa.firstName = 'Theresa'
return p;",,False,False,False,False,False,0,10.44,Error in test case execution: Object of type Path is not JSON serializable,False
36,graph_recursion,hard,Is it possible to get all people from just one person's friends' friends (and so on)? One of the person's name is Matthew.,"match (n:Person)
with count(n) as allPeople
match (p:Person)
where p.firstName = 'Matthew'
with allPeople, p
match (p)-[:IS_FRIEND*0..]-(friend:Person)
with allPeople, count(distinct friend) as friends
return case when friends = allPeople then 'Yes' else 'No' end;
","MATCH (matthew:Person {firstName: 'Matthew'})
WITH matthew
CALL apoc.path.subgraphAll(matthew, {
  relationshipFilter: 'IS_FRIEND',
  maxLevel: 10
}) YIELD nodes
WITH DISTINCT nodes AS allConnectedPeople
UNWIND allConnectedPeople AS person
RETURN person.firstName + ' ' + person.lastName AS fullName
ORDER BY fullName",True,False,False,False,False,782,4.83,{code: Neo.ClientError.Procedure.ProcedureNotFound} {message: There is no procedure with the name `apoc.path.subgraphAll` registered for this database instance. Please ensure you've spelled the procedure name correctly and that the procedure is properly deployed.},False
37,graph_recursion,hard,"On average, how many hops does it take from people living in New Zealand to people working in Johnson-Rogers, Hooper PLC, Patterson, Camacho and White, Rogers-Hobbs, or Ruiz Ltd
","match (kutaiseli:Person)-[:LIVES_IN]-(kutaisi:Location), (maangeli:Person)-[:WORKED_AT]-(maang:Company), path = shortestPath((kutaiseli)-[*]-(maangeli))
where toLower(kutaisi.country) = 'new zealand'
and maang.name in ['Johnson-Rogers', 'Hooper PLC', 'Patterson, Camacho and White', 'Rogers-Hobbs', 'Ruiz Ltd']
and kutaiseli <> maangeli
return avg(length(path));","MATCH (nz:Location {name: 'New Zealand'})
MATCH (p1:Person)-[:LIVES_IN]->(nz)
MATCH (c:Company) WHERE c.name IN ['Johnson-Rogers, Hooper PLC', 'Patterson, Camacho and White', 'Rogers-Hobbs', 'Ruiz Ltd']
MATCH (p2:Person)-[:WORKED_AT]->(c)
WITH p1, p2
MATCH path = shortestPath((p1)-[:IS_FRIEND*1..6]-(p2))
WHERE all(r IN relationships(path) WHERE type(r) = 'IS_FRIEND')
RETURN avg(length(path)) AS averageHops",True,True,False,False,False,819,4.96,,False
38,aggregation,hard,"Based on country, how many different jobs did a person have on average?","match (p:Person)-[:LIVES_IN]->(loc:Location)
where loc.country is not null
optional match (p)-[:HAD_POSITION]->(jt:JobTitle)
with p, loc.country as countryName, count(distinct jt.title) as numberOfDistinctJobs
return countryName, avg(numberOfDistinctJobs) as averageDistinctJobsPerPersonInCountry
order by averageDistinctJobsPerPersonInCountry desc;","MATCH (p:Person)-[:LIVES_IN]->(l:Location)
WITH p, l.country AS country
MATCH (p)-[w:WORKED_AT]->(c:Company)
WITH p, country, COLLECT(DISTINCT w.companyId) AS companies
RETURN country, AVG(SIZE(companies)) AS avgJobsPerPerson
ORDER BY avgJobsPerPerson DESC",True,True,False,False,False,754,4.05,,False
39,aggregation,medium,Find all men who married spouses older than their sisters,"match (sister:Person)<-[:IS_SIBLING]-(man:Person)-[:IS_WIFE|IS_HUSBAND]->(spouse:Person)
where toLower(sister.gender) = 'female'
and toLower(man.gender) = 'male'
and spouse.birthDate < sister.birthDate
return man.firstName","MATCH (m:Person {gender: 'Male'})-[:IS_HUSBAND]->(w:Person)
WHERE m.birthDate < w.birthDate
WITH m, w
MATCH (m)-[:IS_SIBLING]->(s:Person {gender: 'Female'})
WHERE m.birthDate > s.birthDate
RETURN DISTINCT m.firstName + ' ' + m.lastName AS Man,
       w.firstName + ' ' + w.lastName AS Wife,
       s.firstName + ' ' + s.lastName AS Sister",True,True,False,False,False,771,3.89,,False
40,filtering,easy,Find locations such that more men than women live there.,"match (p:Person)-[:LIVES_IN]-(l:Location)
with l.name as location, sum(case when toLower(p.gender) = 'male' then 1 else 0 end) as males, sum(case when toLower(p.gender) = 'female' then 1 else 0 end) as females
where males>females
return location","MATCH (l:Location)<-[:LIVES_IN]-(p:Person)
WITH l, COUNT(CASE WHEN p.gender = 'male' THEN 1 END) AS maleCount,
     COUNT(CASE WHEN p.gender = 'female' THEN 1 END) AS femaleCount
WHERE maleCount > femaleCount
RETURN l.name AS LocationName, maleCount, femaleCount
ORDER BY maleCount - femaleCount DESC",True,True,False,False,False,762,4.09,,False
41,pattern_matching,medium,"Find locations where more men than women live, and display the population of men and women in such places.","match (p:Person)-[:LIVES_IN]-(l:Location)
with l.name as location, sum(case when toLower(p.gender) = 'male' then 1 else 0 end) as males, sum(case when toLower(p.gender) = 'female' then 1 else 0 end) as females
where males>females
return location, males, females;","MATCH (l:Location)<-[:LIVES_IN]-(p:Person)
WITH l, 
     COUNT(CASE WHEN toLower(p.gender) = 'male' THEN p END) AS maleCount,
     COUNT(CASE WHEN toLower(p.gender) = 'female' THEN p END) AS femaleCount
WHERE maleCount > femaleCount
RETURN l.name AS Location, 
       l.population AS TotalPopulation, 
       maleCount AS MalePopulation, 
       femaleCount AS FemalePopulation
ORDER BY l.population DESC",True,True,False,True,True,800,5.06,,False
42,filtering,medium,Return top 3 education institutions with most foreign students.,"match (p:Person)-[lived:LIVED_IN]-(l:Location)
order by p, lived.startYear
with p, collect(l.country)[0] as firstCountry
match (p)-[:STUDIED_AT]-(e:EducationalInstitution)
where firstCountry <> e.country
with e.name as institution, count(*) as foreignStudents
order by foreignStudents desc
limit 3
return institution, foreignStudents;","MATCH (p:Person)-[s:STUDIED_AT]->(e:EducationalInstitution)
WHERE toLower(p.nationality) <> toLower(e.country)
WITH e, COUNT(DISTINCT p) AS foreignStudentCount
ORDER BY foreignStudentCount DESC
LIMIT 3
RETURN e.name AS institution, e.country AS country, foreignStudentCount",True,True,False,True,True,757,5.03,,False
43,filtering,medium,Return education institutions with most foreign students,"match (p:Person)-[lived:LIVED_IN]-(l:Location)
order by p, lived.startYear
with p, collect(l.country)[0] as firstCountry
match (p)-[:STUDIED_AT]-(e:EducationalInstitution)
where firstCountry <> e.country
with e.name as institution, count(*) as foreignStudents
order by foreignStudents desc
return institution;","MATCH (ei:EducationalInstitution)<-[:STUDIED_AT]-(p:Person)
WHERE toLower(p.nationality) <> toLower(ei.country)
WITH ei, COUNT(DISTINCT p) AS foreignStudentCount
ORDER BY foreignStudentCount DESC
LIMIT 10
RETURN ei.name AS institution, ei.country, foreignStudentCount",True,True,False,True,True,753,3.58,,False
44,pattern_matching,easy,Who's older than their husband?,"match (husband:Person)-[:IS_HUSBAND]->(spouse:Person)
where husband.birthDate > spouse.birthDate
return spouse.firstName","MATCH (w:Person)-[:IS_WIFE]->(h:Person)
WHERE date(w.birthDate) < date(h.birthDate)
RETURN w.firstName + ' ' + w.lastName AS Wife, h.firstName + ' ' + h.lastName AS Husband,
       w.birthDate AS WifeBirthDate, h.birthDate AS HusbandBirthDate
ORDER BY w.birthDate",True,True,False,True,True,746,4.24,,False
45,filtering,medium,Find the oldest married person in each city.,"match (l:Location)
where toLower(l.type) = 'city'
optional match (l)-[:LIVES_IN]-(p:Person)-[:IS_HUSBAND|IS_WIFE]->(spouse:Person)
with l.name as city, p
order by city, p.birthDate
with city, collect(p)[0] as oldestMarriedPerson
return city, oldestMarriedPerson.firstName","MATCH (p:Person)-[:LIVES_IN]->(city:Location)
WHERE EXISTS((p)-[:IS_HUSBAND|IS_WIFE]-())
WITH city, p, p.birthDate AS birthDate
ORDER BY birthDate
WITH city, COLLECT(p)[0] AS oldestPerson
RETURN city.name AS City, oldestPerson.firstName + ' ' + oldestPerson.lastName AS OldestMarriedPerson, oldestPerson.birthDate AS BirthDate
ORDER BY city.name",True,True,False,True,True,770,5.12,,False
46,pattern_matching,hard,Family trees where everyone works.,"match (root)-[:IS_HUSBAND|IS_WIFE|IS_PARENT|IS_CHILD|IS_SIBLING*0..50]-(member:Person)
with root, collect(distinct member) as familyMembers
where all(member in familyMembers where exists {
        (member)-[:WORKED_AT]->(c:Company)
        })
and size(familyMembers) > 1
return root.firstName + ' ' + root.lastName as familyRoot,
       [member in familyMembers | member.firstName + ' ' + member.lastName] as employedFamilyMembers
       order by size(familyMembers) desc;","MATCH (root:Person)
WHERE NOT (:Person)-[:IS_PARENT]->(root)
WITH root
MATCH path = (root)-[:IS_PARENT*0..3]->(descendant:Person)
WITH DISTINCT root, COLLECT(DISTINCT descendant) AS familyMembers
WHERE ALL(member IN familyMembers WHERE EXISTS((member)-[:WORKED_AT]->(:Company)))
AND SIZE(familyMembers) > 1
RETURN root.firstName + ' ' + root.lastName AS FamilyHead, 
       SIZE(familyMembers) AS FamilySize,
       [member IN familyMembers | member.firstName + ' ' + member.lastName] AS WorkingFamilyMembers
ORDER BY FamilySize DESC",True,True,False,False,False,814,5.55,,False
47,filtering,easy,Find isolated individuals.,"match (p:Person)
where not exists { (p)-[:IS_HUSBAND|IS_WIFE|IS_PARENT|IS_CHILD|IS_SIBLING]-(p2:Person) }
and not exists { (p)-[:IS_FRIEND]-() }
return p.firstName;","MATCH (p:Person)
WHERE NOT EXISTS {
    (p)-[:IS_FRIEND|WORKED_AT|HAD_POSITION|LIVES_IN|LIVED_IN|IS_HUSBAND|IS_PARENT|STUDIED_AT|STUDIED|IS_WIFE|IS_CHILD|IS_SIBLING]-()
}
RETURN p",True,True,True,,True,724,3.1,,False
48,graph_recursion,hard,Find second cousins.,"match (a:Person)-[:IS_CHILD]->(pa1:Person)-[:IS_CHILD]->(gpa:Person),
      (b:Person)-[:IS_CHILD]->(pb1:Person)-[:IS_CHILD]->(gpb:Person),
      (gpa)-[:IS_CHILD]->(ggp:Person)<-[:IS_CHILD]-(gpb)
where a <> b
and not (a)-[:IS_CHILD]->(:Person)<-[:IS_CHILD]-(b)
and not (a)-[:IS_CHILD]->(:Person)-[:IS_CHILD]->(:Person)<-[:IS_CHILD]-(:Person)<-[:IS_CHILD]-(b)
return a.firstName + ' ' + a.lastName as person1,
       b.firstName + ' ' + b.lastName as person2
       order by person1, person2;",,False,False,False,False,False,0,5.49,Error in test case execution: Object of type Node is not JSON serializable,False
49,filtering,medium,Who has more cousins than siblings?,"match (p:Person)
optional match (p)-[:IS_SIBLING]-(sibling:Person)
with p, count(distinct sibling) AS siblingCount
optional match (p)-[:IS_CHILD]->(parent:Person)-[:IS_SIBLING]->(auntOrUncle:Person)<-[:IS_CHILD]-(cousin:Person)
with p, siblingCount, count(distinct cousin) as cousinCount
where (cousinCount > siblingCount)
return p.firstName, siblingCount, cousinCount;","MATCH (p:Person)
WITH p,
     size([(p)-[:IS_SIBLING]->(sibling) | sibling]) AS siblingCount,
     size([(p)<-[:IS_CHILD]-(parent)-[:IS_SIBLING]->(uncle_aunt)-[:IS_PARENT]->(cousin) WHERE cousin <> p | cousin]) AS cousinCount
WHERE cousinCount > siblingCount
RETURN p.firstName + ' ' + p.lastName AS name, cousinCount, siblingCount
ORDER BY cousinCount DESC",True,True,False,False,False,771,4.7,,False
50,paradox,hard,Which siblings studied before being born?,"match (n)
where 1=2
return n;","MATCH (p1:Person)-[:IS_SIBLING]-(p2:Person)
WHERE p1.id < p2.id
WITH p1, p2
MATCH (p1)-[s1:STUDIED_AT]->(e:EducationalInstitution)
MATCH (p2)-[s2:STUDIED_AT]->(e)
WHERE s1.startYear < toInteger(left(p1.birthDate, 4)) OR s2.startYear < toInteger(left(p2.birthDate, 4))
RETURN p1.firstName + ' ' + p1.lastName AS Sibling1, p2.firstName + ' ' + p2.lastName AS Sibling2, e.name AS Institution,
       CASE WHEN s1.startYear < toInteger(left(p1.birthDate, 4)) THEN p1.firstName + ' ' + p1.lastName
            ELSE p2.firstName + ' ' + p2.lastName END AS StudiedBeforeBirth",True,True,True,False,False,825,5.51,,False
51,filtering,medium,Who's the oldest person without their family?,"match (p:Person)
where not (p)-[:IS_HUSBAND|IS_WIFE|IS_PARENT|IS_CHILD|IS_SIBLING]-(:Person)
return p.firstName
order by p.birthDate
limit 1;",,False,False,False,False,False,0,32.66,Error in test case execution: Object of type Node is not JSON serializable,False
52,filtering,easy,Who's the youngest person with kids?,"match (p:Person)-[:IS_PARENT]->(c:Person)
return p.firstName
order by p.birthDate desc
limit 1;","MATCH (p:Person)-[:IS_PARENT]->(child:Person)
WITH p, COUNT(child) AS childCount, p.birthDate AS birthDate
WHERE childCount > 0
RETURN p.firstName + ' ' + p.lastName AS youngestParent, birthDate
ORDER BY birthDate DESC
LIMIT 1",True,True,False,True,True,738,3.18,,False
53,aggregation,medium,Who is the most well traveled person?,"match (p:Person)-[:LIVED_IN|LIVES_IN]->(loc:Location)
with p, count(distinct loc) as locationCount
order by locationCount desc
limit 1
return p.firstName;","MATCH (p:Person)
WITH p, size((p)-[:LIVED_IN]->()) + size((p)-[:LIVES_IN]->()) AS totalLocations
RETURN p.firstName + ' ' + p.lastName AS mostTraveledPerson, totalLocations
ORDER BY totalLocations DESC
LIMIT 1",True,False,False,False,False,734,5.35,"{code: Neo.ClientError.Statement.SyntaxError} {message: A pattern expression should only be used in order to test the existence of a pattern. It can no longer be used inside the function size(), an alternative is to replace size() with COUNT {}. (line 2, column 14 (offset: 30))
""WITH p, size((p)-[:LIVED_IN]->()) + size((p)-[:LIVES_IN]->()) AS totalLocations""
              ^}",False
54,aggregation,medium,Who is the most popular person with their friends?,"match (p:Person)-[:IS_FRIEND]-(:Person)
with p, count(*) as friendCount
order by friendCount desc
limit 1
return p.firstName;","MATCH (p:Person)
WITH p, size((p)-[:IS_FRIEND]-()) AS friendCount
ORDER BY friendCount DESC
LIMIT 1
RETURN p.firstName + ' ' + p.lastName AS mostPopularPerson, friendCount",True,False,False,False,False,728,3.02,"{code: Neo.ClientError.Statement.SyntaxError} {message: A pattern expression should only be used in order to test the existence of a pattern. It can no longer be used inside the function size(), an alternative is to replace size() with COUNT {}. (line 2, column 14 (offset: 30))
""WITH p, size((p)-[:IS_FRIEND]-()) AS friendCount""
              ^}",False
55,aggregation,medium,Find people who have changed location 3 times.,"match (p:Person)-[:LIVES_IN|LIVED_IN]-(l:Location)
with p, count(l) as locations
where locations > 3
return p.firstName;","MATCH (p:Person)
WITH p, [(p)-[:LIVED_IN]->(l:Location) | l] AS locations
WHERE size(locations) = 3
RETURN p.firstName + ' ' + p.lastName AS name, [loc.name for loc in locations] AS livedInLocations",True,False,False,False,False,734,3.8,"{code: Neo.ClientError.Statement.SyntaxError} {message: Invalid input 'for': expected an expression, ',' or ']' (line 4, column 58 (offset: 157))
""RETURN p.firstName + ' ' + p.lastName AS name, [loc.name for loc in locations] AS livedInLocations""
                                                          ^}",False
56,Inconclusive,medium,Show people who are friends on Facebook.,"match (n)
 where 1=2
return n;","MATCH (p1:Person)-[r:IS_FRIEND]->(p2:Person)
WHERE toLower(r.since) CONTAINS 'facebook'
RETURN p1.firstName + ' ' + p1.lastName AS Person1, p2.firstName + ' ' + p2.lastName AS Person2",True,True,True,False,False,728,3.32,,False
57,filtering,medium,List people whose jobs rhyme with the word preacher.,"match (p:Person)-[:HAD_POSITION]->(jt:JobTitle)
where toLower(jt.title) ends with 'eacher'
return distinct p.firstName;","MATCH (p:Person)-[:HAD_POSITION]->(j:JobTitle)
WHERE toLower(j.title) =~ '.*cher$'
RETURN DISTINCT p.firstName + ' ' + p.lastName AS name, j.title AS job
ORDER BY name",True,True,False,True,True,727,3.42,,False
58,filtering,medium,Find people currently living in a city they were born in.,"match (p:Person)-[:LIVES_IN]->(loc:Location)
where p.birthPlace = loc.name
return p.firstName;",,False,False,False,False,False,0,34.26,"Error in test case execution: Claude API Error: Error code: 529 - {'type': 'error', 'error': {'type': 'overloaded_error', 'message': 'Overloaded'}}",False
60,filtering,medium,Find siblings who studied the same things.,"match (a:Person)-[:IS_SIBLING]->(b:Person),
(a)-[:STUDIED]->(fieldA:FieldOfStudy),
(b)-[:STUDIED]->(fieldB:FieldOfStudy)
where fieldA.name = fieldB.name
return distinct a.firstName, b.firstName;","MATCH (p1:Person)-[:IS_SIBLING]->(p2:Person)
WHERE id(p1) < id(p2)
WITH p1, p2
MATCH (p1)-[:STUDIED]->(f:FieldOfStudy)<-[:STUDIED]-(p2)
RETURN p1.firstName + ' ' + p1.lastName AS Sibling1,
       p2.firstName + ' ' + p2.lastName AS Sibling2,
       collect(f.name) AS SharedFields
ORDER BY size(SharedFields) DESC",True,True,True,True,True,761,5.11,,False
61,filtering,medium,Find palindromic first names in the database.,"match (p:Person)
where toLower(p.firstName) = reverse(toLower(p.firstName))
return p.firstName;","MATCH (p:Person)
WHERE toLower(p.firstName) = reverse(toLower(p.firstName))
RETURN p.firstName AS PalindromicFirstName
ORDER BY PalindromicFirstName",True,True,False,True,True,721,3.33,,False
62,filtering,medium,Find all the people who are both a child and a parent.,"match (child:Person)-[:IS_CHILD]->(p:Person)-[:IS_CHILD]->(parent:Person)
return distinct p.firstName;",,False,False,False,False,False,0,2.79,Error in test case execution: Object of type Node is not JSON serializable,False
63,filtering,medium,List people who have both a parent and a child in the graph.,"match (child:Person)-[:IS_CHILD]->(p:Person)-[:IS_CHILD]->(parent:Person)
return distinct p.firstName;","MATCH (p:Person)
WHERE EXISTS((p)<-[:IS_PARENT]-(:Person))
  AND EXISTS((p)-[:IS_PARENT]->(:Person))
RETURN p.firstName + ' ' + p.lastName AS name, p.id AS id",True,True,False,True,True,727,2.71,,False
64,pattern_matching,medium,Find married couples that live in different cities.,"match (p1:Person)-[:IS_HUSBAND|IS_WIFE]->(p2:Person),
(p1)-[:LIVES_IN]->(loc1:Location),
(p2)-[:LIVES_IN]->(loc2:Location)
where loc1.name <> loc2.name
and p1.id < p2.id
return p1.firstName, p2.firstName;","MATCH (p1:Person)-[:IS_HUSBAND|IS_WIFE]->(p2:Person)
WHERE NOT (p1)-[:LIVES_IN]->()<-[:LIVES_IN]-(p2)
WITH p1, p2
MATCH (p1)-[:LIVES_IN]->(l1:Location), (p2)-[:LIVES_IN]->(l2:Location)
WHERE l1 <> l2
RETURN p1.firstName + ' ' + p1.lastName AS Partner1, 
       p2.firstName + ' ' + p2.lastName AS Partner2, 
       l1.name AS City1, 
       l2.name AS City2",True,True,False,False,False,775,3.84,,False
65,graph_recursion,hard,Find all friend groups of 3.,"match (p1:Person)-[:IS_FRIEND]->(p2:Person)-[:IS_FRIEND]->(p3:Person),
      (p3)-[:IS_FRIEND]->(p1)
where p1.id < p2.id
and p2.id < p3.id
return p1.firstName, p2.firstName, p3.firstName;","MATCH (p1:Person)-[:IS_FRIEND]->(p2:Person)-[:IS_FRIEND]->(p3:Person)-[:IS_FRIEND]->(p1)
WHERE id(p1) < id(p2) AND id(p2) < id(p3)
RETURN p1.firstName + ' ' + p1.lastName AS Person1,
       p2.firstName + ' ' + p2.lastName AS Person2,
       p3.firstName + ' ' + p3.lastName AS Person3",True,True,False,True,True,751,3.2,,False
66,filtering,medium,Look for all degrees held by people and count them per degree type.,"match (p:Person)-[r:STUDIED]->(f:FieldOfStudy)
return r.degree, count(*);","MATCH (p:Person)-[s:STUDIED_AT]->(e:EducationalInstitution)
WHERE s.degree IS NOT NULL
RETURN LOWER(s.degree) AS degree, COUNT(*) AS count
ORDER BY count DESC",True,True,False,True,True,729,2.55,,False
67,pattern_matching,hard,"Find people with double letter initials, like N.N.","match (p:Person)
where left(p.firstName, 1) = left(p.lastName, 1)
return p.firstName, p.lastName;","MATCH (p:Person)
WHERE toLower(left(p.firstName, 1)) = toLower(left(p.lastName, 1))
AND size(p.firstName) > 1 AND size(p.lastName) > 1
RETURN p.firstName, p.lastName",True,True,True,,True,726,2.46,,False
68,filtering,medium,Find names that are both first names and last names in the database.,"match (p1:Person), (p2:Person)
where p1.firstName = p2.lastName
return distinct p1.firstName;","MATCH (p1:Person), (p2:Person)
WHERE toLower(p1.firstName) = toLower(p2.lastName)
RETURN DISTINCT p1.firstName AS name
ORDER BY name",True,True,False,True,True,723,2.75,,False
69,filtering,medium,Find people who are missing birthdates.,"match (p:Person)
where p.birthDate is null
return p.firstName;","MATCH (p:Person)
WHERE p.birthDate IS NULL
RETURN p.id, p.firstName, p.lastName",True,True,True,,True,702,2.44,,False
70,filtering,easy,Which companies were founded in the same year?,"match (c1:Company), (c2:Company)
where c1.foundedYear = c2.foundedYear
and c1.id < c2.id
return c1.name, c2.name;","MATCH (c1:Company), (c2:Company)
WHERE c1.foundedYear = c2.foundedYear AND id(c1) < id(c2)
RETURN c1.name AS Company1, c2.name AS Company2, c1.foundedYear AS FoundedYear
ORDER BY c1.foundedYear",True,True,True,,True,732,2.86,,False
71,filtering,easy,Show me all universities founded before 1800.,"match (e:EducationalInstitution)
where e.foundedYear < 1800
return e.name;","MATCH (u:EducationalInstitution)
WHERE u.type = 'university' AND u.foundedYear < 1800
RETURN u.name, u.foundedYear, u.country
ORDER BY u.foundedYear",True,True,False,False,False,721,2.64,,False
72,pattern_matching,easy,Find people who share the same birthday.,"match (p1:Person), (p2:Person)
where date(p1.birthDate).month = date(p2.birthDate).month
and date(p1.birthDate).day = date(p2.birthDate).day
and p1.id < p2.id
return p1.firstName, p2.firstName;","MATCH (p1:Person), (p2:Person)
WHERE p1 <> p2 AND toLower(p1.birthDate) = toLower(p2.birthDate)
RETURN p1.firstName + ' ' + p1.lastName AS Person1, 
       p2.firstName + ' ' + p2.lastName AS Person2, 
       p1.birthDate AS SharedBirthday
ORDER BY SharedBirthday, Person1, Person2",True,True,False,,False,753,3.03,,False
73,filtering,easy,List all job titles in the management category.,"match (j:JobTitle)
where toLower(j.category) = 'management'
return j.title;","MATCH (j:JobTitle)
WHERE toLower(j.category) = 'management'
RETURN j.title AS JobTitle
ORDER BY JobTitle",True,True,False,True,True,710,2.04,,False
74,filtering,easy,What fields of study belong to the humanities category?,"match (f:FieldOfStudy)
where toLower(f.category) = 'humanities'
return f.name;","MATCH (f:FieldOfStudy)
WHERE toLower(f.category) = 'humanities'
RETURN f.name AS fieldOfStudy",True,True,False,True,True,710,2.21,,False
75,pattern_matching,easy,Find people whose email domain matches their company name.,"match (p:Person)-[:WORKED_AT]-(c:Company)
where toLower(p.email) contains c.name
return p.firstName;","MATCH (p:Person)-[:WORKED_AT]->(c:Company)
WHERE toLower(split(p.email, '@')[1]) CONTAINS toLower(c.name)
RETURN p.firstName, p.lastName, p.email, c.name",True,True,True,,True,725,2.08,,False
76,filtering,easy,Show me all cities with population over 1 million.,"match (l:Location)
where toLower(l.type) = 'city'
and l.population > 1000000
return l.name;","MATCH (l:Location)
WHERE l.type = 'city' AND l.population > 1000000
RETURN l.name AS City, l.population AS Population
ORDER BY l.population DESC",True,True,False,False,False,721,1.84,,False
77,filtering,easy,Who graduated from university in 2016?,"match (p:Person)-[s:STUDIED_AT]-(e:EducationalInstitution)
where s.endYear = 2016
return p.firstName;","MATCH (p:Person)-[s:STUDIED_AT]->(e:EducationalInstitution)
WHERE s.endYear = 2016 AND s.status = 'graduated'
RETURN p.firstName + ' ' + p.lastName AS graduate, e.name AS university",True,True,False,False,False,727,3.01,,False
78,aggregation,medium,Which married couples have the biggest age gap?,"match (p1:Person)-[:IS_HUSBAND|IS_WIFE]-(p2:Person)
with p1, p2, duration.between(date(p2.birthDate), date(p1.birthDate)) as ageGap
return p1.firstName, p2.firstName
order by ageGap desc
limit 1;","MATCH (p1:Person)-[:IS_HUSBAND|IS_WIFE]->(p2:Person)
WHERE p1.birthDate IS NOT NULL AND p2.birthDate IS NOT NULL
WITH p1, p2, date(p1.birthDate) AS bd1, date(p2.birthDate) AS bd2
WITH p1, p2, duration.between(bd1, bd2).years AS ageDiff
RETURN p1.firstName + ' ' + p1.lastName AS Person1, 
       p2.firstName + ' ' + p2.lastName AS Person2, 
       abs(ageDiff) AS AgeDifference
ORDER BY AgeDifference DESC
LIMIT 10",True,True,False,False,False,788,3.52,,False
79,filtering,medium,Show me people who studied longer than 4 years at university.,"match (p:Person)-[s:STUDIED_AT]-(e:EducationalInstitution)
where s.endYear - s.startYear > 4
return p.firstName;","MATCH (p:Person)-[s:STUDIED_AT]->(e:EducationalInstitution)
WHERE e.type = 'university' AND s.endYear - s.startYear > 4
RETURN p.firstName + ' ' + p.lastName AS name, e.name AS university, s.startYear AS startYear, s.endYear AS endYear, s.endYear - s.startYear AS yearsStudied
ORDER BY yearsStudied DESC",True,True,False,False,False,764,2.97,,False
80,pattern_matching,medium,Find friends who work in competing companies in the same industry.,"match (p1:Person)-[w1:WORKED_AT]-(c1:Company),
      (p2:Person)-[w2:WORKED_AT]-(c2:Company)
where p1.id < p2.id
and c1.id <> c2.id
and c1.industry = c2.industry
and w1.endYear is null
and w2.endYear is null
return p1.firstName, p2.firstName;","MATCH (p1:Person)-[:IS_FRIEND]->(p2:Person)
WHERE p1 <> p2
MATCH (p1)-[w1:WORKED_AT]->(c1:Company)
MATCH (p2)-[w2:WORKED_AT]->(c2:Company)
WHERE c1 <> c2 AND c1.industry = c2.industry
  AND w1.status = 'CURRENT' AND w2.status = 'CURRENT'
RETURN p1.firstName + ' ' + p1.lastName AS Person1,
       p2.firstName + ' ' + p2.lastName AS Person2,
       c1.name AS Company1,
       c2.name AS Company2,
       c1.industry AS Industry",True,True,False,False,False,796,4.21,,False
81,filtering,medium,Find people who started working before finishing their studies.,"match (e:EducationalInstitution)-[s:STUDIED_AT]-(p:Person)-[w:WORKED_AT]-(c:Company)
where w.startYear < s.endYear
return p.firstName;","MATCH (p:Person)-[s:STUDIED_AT]->(e:EducationalInstitution), (p)-[w:WORKED_AT]->(c:Company)
WHERE w.startYear < s.endYear
RETURN DISTINCT p.firstName + ' ' + p.lastName AS name, e.name AS institution, c.name AS company, s.startYear AS studyStartYear, s.endYear AS studyEndYear, w.startYear AS workStartYear
ORDER BY p.lastName, p.firstName",True,False,False,False,False,773,2.87,"{code: Neo.ClientError.Statement.SyntaxError} {message: In a WITH/RETURN with DISTINCT or an aggregation, it is not possible to access variables declared before the WITH/RETURN: p (line 4, column 10 (offset: 316))
""ORDER BY p.lastName, p.firstName""
          ^}",False
82,aggregation,medium,Which field of study has the shortest average study duration?,"match (p:Person)-[s:STUDIED]-(f:FieldOfStudy)
where s.endYear is not null
with f, avg(s.endYear - s.startYear) as studyDuration
return f.name
order by studyDuration
limit 1;","MATCH (p:Person)-[s:STUDIED]->(f:FieldOfStudy)
WITH f, AVG(s.endYear - s.startYear) AS avgDuration
RETURN f.name AS FieldOfStudy, avgDuration
ORDER BY avgDuration ASC
LIMIT 1",True,True,False,True,True,731,2.31,,False
83,pattern_matching,medium,Show me parent-child pairs who work in the same company.,"match (c:Company)-[w1:WORKED_AT]-(child:Person)-[:IS_CHILD]->(parent:Person)-[w2:WORKED_AT]-(c)
where w1.endYear is null
and w2.endYear is null
return child.firstName, parent.firstName;","MATCH (parent:Person)-[:IS_PARENT]->(child:Person)
WHERE EXISTS((parent)-[:WORKED_AT]->(company:Company)<-[:WORKED_AT]-(child))
RETURN parent.firstName + ' ' + parent.lastName AS Parent, 
       child.firstName + ' ' + child.lastName AS Child, 
       company.name AS Company",True,False,False,,False,755,2.39,"{code: Neo.ClientError.Statement.SyntaxError} {message: PatternExpressions are not allowed to introduce new variables: 'company'. (line 2, column 38 (offset: 88))
""WHERE EXISTS((parent)-[:WORKED_AT]->(company:Company)<-[:WORKED_AT]-(child))""
                                      ^}",False
84,graph_recursion,hard,Find family dynasties where multiple generations attended the same university.,"match path = (p1:Person)-[:IS_CHILD*1..5]->(p2:Person),
      (p1)-[:STUDIED_AT]->(u:EducationalInstitution),
      (p2)-[:STUDIED_AT]->(u)
with collect(distinct p1) + collect(distinct p2) as family
return [p in family | p.firstName];","MATCH (p1:Person)-[:IS_PARENT*1..3]->(p2:Person)
WHERE p1 <> p2
WITH p1, p2
MATCH (p1)-[:STUDIED_AT]->(uni:EducationalInstitution)<-[:STUDIED_AT]-(p2)
WITH DISTINCT p1, p2, uni
MATCH path = (p1)-[:IS_PARENT*1..3]->(p2)
WITH p1, p2, uni, [node IN nodes(path) | node.firstName + ' ' + node.lastName] AS familyMembers
RETURN DISTINCT uni.name AS University, familyMembers AS FamilyDynasty
ORDER BY University, size(familyMembers) DESC",True,True,False,True,True,800,9.04,,False
85,pattern_matching,hard,Detect circular migration patterns where people return to their birth country after living abroad.,"match (p:Person)-[l1:LIVED_IN]->(loc1:Location)
with p, loc1
order by p, l1.startYear
with p, collect(loc1)[0] as origin
match (p)-[l2:LIVED_IN]->(loc2:Location)
where loc2.country <> origin.country
with p, origin, max(l2.startYear) as abroadYear
match (p)-[l3:LIVES_IN]->(loc3:Location)
where l3.startYear > abroadYear and loc3.country = origin.country
return distinct p.firstName;","MATCH (p:Person)-[:LIVED_IN]->(l:Location)
WHERE l.country <> toLower(p.birthPlace)
WITH p, l
MATCH (p)-[:LIVES_IN]->(current:Location)
WHERE toLower(current.country) = toLower(p.birthPlace) AND current.country <> l.country
RETURN p.firstName + ' ' + p.lastName AS name, 
       p.birthPlace AS birthCountry, 
       l.country AS livedCountry, 
       current.country AS currentCountry",True,True,True,,True,793,3.44,,False
86,pattern_matching,hard,Find anomalies in educational timelines where people studied multiple degrees simultaneously.,"match (f1:FieldOfStudy)-[s1:STUDIED]-(p:Person)-[s2:STUDIED]-(f2:FieldOfStudy)
where s1.startYear > s2.startYear
and s1.startYear < s2.endYear
return p.firstName, s1.degree, s2.degree;","MATCH (p:Person)-[s1:STUDIED_AT]->(e1:EducationalInstitution)
WITH p, s1, e1
MATCH (p)-[s2:STUDIED_AT]->(e2:EducationalInstitution)
WHERE id(e1) < id(e2) 
  AND ((s1.startYear <= s2.startYear AND s1.endYear >= s2.startYear)
    OR (s2.startYear <= s1.startYear AND s2.endYear >= s1.startYear))
RETURN p.firstName + ' ' + p.lastName AS PersonName,
       e1.name AS Institution1, s1.degree AS Degree1, s1.startYear AS Start1, s1.endYear AS End1,
       e2.name AS Institution2, s2.degree AS Degree2, s2.startYear AS Start2, s2.endYear AS End2
ORDER BY PersonName, Start1, Start2",True,True,False,False,False,840,4.92,,False
87,filtering,easy,Find people who never changed their location.,"match (p:Person)
where not exists {(p)-[:LIVED_IN]-(l:Location)}
return p.firstName;",,False,False,False,False,False,0,2.4,Error in test case execution: Object of type Node is not JSON serializable,False
88,filtering,easy,Which company has the smallest number of employees?,"match (p:Person)-[w:WORKED_AT]-(c:Company)
where w.endYear is null
with c, count(distinct p) as workers
order by workers
return c.name
limit 1;","MATCH (c:Company)
WHERE c.employees IS NOT NULL
RETURN c.name AS CompanyName, c.employees AS EmployeeCount
ORDER BY c.employees ASC
LIMIT 1",True,True,False,True,True,720,2.52,,False
89,filtering,easy,Show me all people with Gmail email addresses.,"match (p:Person)
where toLower(p.email) contains 'gmail'
return p.firstName, p.email;","MATCH (p:Person)
WHERE p.email CONTAINS '@gmail.com'
RETURN p",True,True,True,,True,699,1.65,,False
90,filtering,easy,Find all educational institutions of type 'College'.,"match (e:EducationalInstitution)
where toLower(e.type) = 'college'
return e.name;",,False,False,False,False,False,0,2.42,Error in test case execution: Object of type Node is not JSON serializable,False
91,filtering,easy,List people who are currently unemployed.,"match (p:Person)
where not exists {(p)-[w:WORKED_AT]-(c:Company)
                   where w.endYear is null}
return p.firstName, p.lastName;","MATCH (p:Person)
WHERE NOT EXISTS((p)-[:WORKED_AT]->(:Company {status: 'current'}))
  AND NOT EXISTS((p)-[:HAD_POSITION]->(:JobTitle {status: 'current'}))
RETURN p.firstName + ' ' + p.lastName AS unemployedPerson",True,True,False,False,False,736,2.63,,False
92,filtering,easy,Which field of study has the most students enrolled?,"match (p:Person)-[s:STUDIED]-(f:FieldOfStudy)
where s.endYear is null
with f, count(p) as enrolled
order by enrolled desc
return f.name
limit 1;","MATCH (f:FieldOfStudy)<-[:STUDIED]-(p:Person)
WITH f, COUNT(DISTINCT p) AS studentCount
RETURN f.name AS fieldOfStudy, studentCount
ORDER BY studentCount DESC
LIMIT 1",True,True,False,False,False,727,3.01,,False
93,pattern_matching,medium,Find people born in the same decade.,"match (p1:Person), (p2:Person)
where p1.id < p2.id
and toInteger(date(p1.birthDate).year / 10) = toInteger(date(p2.birthDate).year / 10)
return p1.firstName, p2.firstName, p1.birthDate, p2.birthDate;","MATCH (p1:Person), (p2:Person)
WHERE p1 <> p2
  AND toInteger(left(p1.birthDate, 3) + '0') = toInteger(left(p2.birthDate, 3) + '0')
RETURN p1.firstName + ' ' + p1.lastName AS Person1,
       p2.firstName + ' ' + p2.lastName AS Person2,
       toInteger(left(p1.birthDate, 3) + '0') AS Decade
ORDER BY Decade, Person1, Person2",True,True,False,,False,763,3.85,,False
94,filtering,easy,Which locations are classified as 'City' type?,"match (l:Location)
where toLower(l.type) = 'city'
return l.name;","MATCH (l:Location)
WHERE l.type = 'City'
RETURN l.name AS CityName, l.country AS Country, l.population AS Population
ORDER BY l.population DESC",True,True,False,True,True,720,2.63,,False
95,filtering,easy,Find companies founded in the 21st century.,"match (c:Company)
where c.foundedYear > 2000
return c.name;","MATCH (c:Company)
WHERE c.foundedYear >= 2000
RETURN c.name AS CompanyName, c.foundedYear AS FoundedYear
ORDER BY c.foundedYear",True,True,False,True,True,715,2.45,,False
96,aggregation,medium,Which industry has the highest average company founding year?,"match (c:Company)
with c.industry as industry, avg(c.foundedYear) as averageFunded
return industry
order by averageFunded desc
limit 1;","MATCH (c:Company)
WHERE c.foundedYear IS NOT NULL AND c.industry IS NOT NULL
WITH c.industry AS industry, AVG(c.foundedYear) AS avgFoundingYear
RETURN industry, avgFoundingYear
ORDER BY avgFoundingYear DESC
LIMIT 1",True,True,False,True,True,741,2.45,,False
97,filtering,medium,Find friends who have never lived in the same location at the same time.,"match (p1:Person)-[:IS_FRIEND]-(p2:Person)
where p1.id < p2.id
and not exists {(p1)-[:LIVES_IN]-(:Location)-[:LIVES_IN]-(p2)}
and not exists {(p1)-[l1:LIVED_IN|LIVES_IN]-(:Location)-[l2:LIVED_IN|LIVES_IN]-(p2)
               where coalesce(l1.endYear, date().year) > l2.startYear
               and coalesce(l2.endYear, date().year) > l1.startYear}
return distinct p1.firstName, p2.firstName;","MATCH (p1:Person)-[:IS_FRIEND]->(p2:Person)
WHERE NOT EXISTS {
    MATCH (p1)-[l1:LIVED_IN]->(loc:Location)<-[l2:LIVED_IN]-(p2)
    WHERE l1.startYear <= l2.endYear AND l1.endYear >= l2.startYear
}
AND p1 <> p2
RETURN p1.firstName + ' ' + p1.lastName AS Person1, 
       p2.firstName + ' ' + p2.lastName AS Person2",True,True,False,False,False,769,3.59,,False
98,filtering,easy,What is the most common birth month?,"match (p:Person)
with date(p.birthDate).month as birthMonth, count(*) as born
order by born desc
return birthMonth
limit 1;","MATCH (p:Person)
WHERE p.birthDate IS NOT NULL
WITH split(p.birthDate, '-')[1] AS birthMonth, count(*) AS count
RETURN birthMonth, count
ORDER BY count DESC
LIMIT 1",True,True,False,True,True,723,2.49,,False
99,filtering,easy,How many people have the same first and last name?,"match (p:Person)
where p.firstName = p.lastName
return count(p);","MATCH (p1:Person), (p2:Person)
WHERE p1 <> p2 AND toLower(p1.firstName) = toLower(p2.firstName) AND toLower(p1.lastName) = toLower(p2.lastName)
WITH count(DISTINCT p1) AS count
RETURN count",True,True,False,True,True,732,2.76,,False
100,paradox,easy,How many people were born on the sun?,"match (n)
where 1=2
return n;","MATCH (p:Person)
WHERE toLower(p.birthPlace) = 'sun'
RETURN count(p) AS peopleCountBornOnSun",True,True,False,False,False,705,2.65,,False
